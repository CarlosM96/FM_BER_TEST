import os
import sys
import random
from migen import *
from migen.genlib.io import CRG
#from gtprx import GTPQuadPLL, GTP
from migen.fhdl import verilog
from tx import TX
#from rx import RX
#from ac701 import Platform
from prbs import PRBSGenerator

from memory import mem
class FullModeSim(Module):
    def __init__(self,platform):
        """
        we: Write button. When is asserted, all data and data type from 
        memory is written into the FIFO. 
        link_ready: When is asserted, the transmision starts.
        trans_en: When is asserted, the transmision of data received in
        RX to the PC via UART starts.
        reset: General reset
        """
        self.link_ready=Signal()
        self.we=Signal()
        self.act = Signal()
        self.trans_en=Signal()
        self.led0=Signal()
        self.led1=Signal()
        self.led2=Signal()
        self.led3=Signal()
        self.reset=Signal()
        self.sys_clk=Signal()
        self.tx_clk=Signal()
        self.txinit_done=Signal()    
        self.tx_data=Signal(32)
        self.rx_data=Signal(32)      
        self.tx_k=Signal()
     

        tx=TX()
        link_ready=Signal()
        we=Signal()
        

        n_data=1000 #number of data generated by the PRBS
        n_packages=3 #number of data packages
        
        if self.act:
        	link_ready = 1
        	we = 1
        else:
        	we = 0
        self.submodules+=[tx]
        
        generator_sel=0 #1 for memory, 0 for PRBS
        
        if generator_sel:
            memory=mem()
           # memory=ClockDomainsRenamer("write")(memory)
            self.submodules+=memory
            index=Signal(5) #Memory index
            write_fifo=Signal() #fifo write enable
            #FSM to control the FIFO writing process
            self.submodules.memory_fsm=FSM(reset_state="INIT")
            self.memory_fsm=ClockDomainsRenamer("write")(self.memory_fsm)
            self.memory_fsm.act("INIT",
                If(self.we,
                    NextValue(index,1),
                    NextState("WRITING"),
                    NextValue(write_fifo,1),
                )
            )
            self.memory_fsm.act("WRITING",
                
                NextValue(index,index+1),
                If(index==(memory.n_value), #Last word reached
                    
                    NextValue(index,0),
                    NextState("WRITING_EOP"),
                    NextValue(write_fifo,0)
                )    
            )
            self.memory_fsm.act("WRITING_EOP",
                NextState("IDLE"),
                
            )
            self.memory_fsm.act("IDLE",
                If(~self.we, #Process starts again
                    NextState("INIT")
                )
            )
            self.comb+=[
                fifo.din.eq(memory.data_out),
                fifo.dtin.eq(memory.type_out),
                fifo.we.eq(write_fifo),
                memory.index.eq(index)
            ]

        else:
            prbs=PRBSGenerator(n_out=32)
            prbs=ClockDomainsRenamer("tx")(prbs)
            self.submodules+=prbs
            self.counter=counter=Signal(16)
            prbs_en=Signal()
            data_type=Signal(2)
            index=Signal(max=n_data+2)
            pack_index=Signal(max=n_packages+2)
            i_ignored=Signal(max=n_data-1)
            write_fifo=Signal()
            idle_counter=Signal(2)
            aux=Signal()
            done_packs=Signal()
            self.comb+=i_ignored.eq(random.randint(2,n_data-1))
            self.submodules.prbs_fsm=FSM(reset_state="INIT")
            self.prbs_fsm=ClockDomainsRenamer("tx")(self.prbs_fsm)
            self.prbs_fsm.act("INIT",
                If(self.we & (~done_packs),
                   
                    NextValue(data_type,1),
                    NextValue(write_fifo,1),
                    NextState("SOP")
                )
            )
            self.prbs_fsm.act("SOP",
                If(~aux, NextValue(prbs_en,1)),
                NextValue(data_type,0),
                NextValue(index,index+1),
                NextState("MIDDLE_WORD")
            )    
            
            self.prbs_fsm.act("MIDDLE_WORD",
                NextValue(prbs_en,1),
                If(index<n_data,
                    NextValue(data_type,0b00),
                    NextValue(index,index+1),
                    NextState("MIDDLE_WORD")
                ).Else(
                    NextState("EOP"),
                    NextValue(data_type,0b10),
                    NextValue(index,0)
                )
            )
            self.prbs_fsm.act("EOP",
                NextValue(prbs_en,0),
                NextValue(write_fifo,0),
                NextState("WAITS_RESET")
            )
            self.prbs_fsm.act("WAITS_RESET",
                If(idle_counter<3,
                    NextValue(idle_counter,idle_counter+1),    
                ).Else(
                    NextValue(pack_index,pack_index+1),
                    NextValue(idle_counter,0),    
                    If(pack_index<=n_packages,
                        NextValue(data_type,1),
                        NextValue(aux,1),
                        NextValue(write_fifo,1),
                        NextState("SOP")
                    ).Else(
                        NextState("INIT"),
                        NextValue(done_packs,1)
                        NextValue(link_ready,0)

                    )
                )
                
                
            )
 
            self.comb+=[
                
                prbs.enable.eq(prbs_en),
                
            ]



        self.comb+=[
            
            tx.link_ready.eq(self.link_ready),
            
            tx.tx_init_done.eq(self.txinit_done),
            If(self.link_ready, 
                tx.data_type_in.eq(data_type),
                tx.data_in.eq(prbs.o), 
            ),

            self.tx_k.eq(tx.k),
            self.led0.eq(self.txinit_done),
            If((self.we),
                self.led3.eq(1)
            ),
            self.tx_data.eq(tx.data_out),
            If(self.link_ready,
                self.led2.eq(1)
            )
        ]

def generate_top():
    platform = Platform()
    soc = FullModeSim(platform)
    platform.build(soc, build_dir="./", run=False)
    #platform.build(soc)

def generate_top_tb():
    f = open("top_tb.v", "w")
    f.write("""
`timescale 1ns/1ps

module top_tb();

reg gtp_clk;
initial gtp_clk = 1'b1;
always #2.08333 gtp_clk = ~gtp_clk; //2.08333 is half period of 240 MHz gtp clk

reg sys_clk;
initial sys_clk = 1'b1;
always #2.5 sys_clk = ~sys_clk; //2.5 is half period of 200 MHz sys clk

real period =3.333; //400 MHz period

reg link_ready;
initial link_ready=0;
reg we;

reg reset;
initial reset='b0;
initial we='b0;

reg trans_en;
initial trans_en=0;

wire gtp_p;
wire gtp_n;
wire rxinitdone;
wire serial_tx;

top dut (
    .smatx_p(gtp_p),
    .smatx_n(gtp_n),
    .smarx_p(gtp_p),
    .smarx_n(gtp_n),
    .gtp_refclk_p(gtp_clk),
    .gtp_refclk_n(~gtp_clk),
    .sw2_0(link_ready),
    .sw2_1(we),
    .sw2_2(trans_en),
    .cpu_reset(reset),
    .rxinitdone(rxinitdone),
    .clk200_p(sys_clk),
    .clk200_n(~sys_clk),
    .serial_tx(serial_tx)
    
);


always begin 
    //Waits signals initialization
    for (integer i=0;i<=4000;i=i+1) begin
        #period;
    end
    
    while(~rxinitdone) begin
        #period;
    end
    
    for (integer i=0;i<=15000;i=i+1) begin
        #period;
    end
    

    //Starts transmision. It will send IDLE because FIFO is empty yet
    link_ready=1'b1; 
    for (integer i=0;i<=15000;i=i+1) begin
        #period;
    end
    
    //The writing process starts
    we=1'b1;


    for (integer i=0;i<=15000;i=i+1) begin
        #period;
    end

    trans_en=1'b1;
    
    while(1) begin
        #period;
    end

    we=1'b0;
    #period;
    we=1'b1;
    //The writing process starts again
    for (integer i=0;i<=35000;i=i+1) begin
        #period;
    end

    
end
endmodule""")
    f.close()

dut = FullModeSim(platform=0)   
verilog.convert(dut, {dut.link_ready,dut.reset, 
    dut.tx_data,dut.txinit_done, dut.tx_clk,
    dut.tx_k, dut.led0, dut.led1, dut.led2, dut.led3, dut.we}).write("top_logic_n_packs.v")
    
